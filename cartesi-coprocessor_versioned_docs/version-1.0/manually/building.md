# Building your dApp

:::warning
All the instructions listed on this page are done manually and focused at deploying to a testnet. For less effort and better developer experience, please refer to the [CLI Section](../building.md#building-your-dapp).
:::

## Step 1: Run Nonodo with Cartesi Machine

1. **Start Nonodo**:

   ```bash
   nonodo
   ```

2. **Create and Build a new Cartesi dApp**:
   - Use the commands below based on your preferred programming language.

---

### **Python**

1. Create a new project:
   ```bash
   cartesi create my-dapp --template=python --branch "wip/coprocessor"
   cd my-dapp
   cartesi build
   ```
2. Run the Cartesi Machine locally:
   ```bash
   cartesi-machine --network --flash-drive=label:root,filename:.cartesi/image.ext2 \
   --volume=.:/mnt --env=ROLLUP_HTTP_SERVER_URL=http://10.0.2.2:5004 --workdir=/mnt -- python dapp.py
   ```

---

### **Rust**

1. Create a new project:
   ```bash
   cartesi create my-dapp --template=rust --branch "wip/coprocessor"
   cd my-dapp
   cartesi build
   ```
2. Run the Cartesi Machine locally:
   ```bash
   cartesi-machine --network --flash-drive=label:root,filename:.cartesi/image.ext2 \
   --env=ROLLUP_HTTP_SERVER_URL=http://10.0.2.2:5004 -- /opt/cartesi/dapp/dapp
   ```

---

### **Go**

1. Create a new project:
   ```bash
   cartesi create my-dapp --template=go --branch "wip/coprocessor"
   cd my-dapp
   cartesi build
   ```
2. Run the Cartesi Machine locally:
   ```bash
   cartesi-machine --network --flash-drive=label:root,filename:.cartesi/image.ext2 \
   --env=ROLLUP_HTTP_SERVER_URL=http://10.0.2.2:5004 -- /opt/cartesi/dapp/dapp
   ```

---

### **JavaScript**

1. Create a new project:
   ```bash
   cartesi create my-dapp --template=javascript --branch "wip/coprocessor"
   cd my-dapp
   cartesi build
   ```
2. Run the Cartesi Machine locally:
   ```bash
   cartesi-machine --network --flash-drive=label:root,filename:.cartesi/image.ext2 \
   --volume=.:/mnt --env=ROLLUP_HTTP_SERVER_URL=http://10.0.2.2:5004 --workdir=/opt/cartesi/dapp -- node index
   ```

## Step 2: Run CARize Utility Container

After building your dApp, use the CARize container to generate the necessary files:

```bash
docker run --rm \
    -v $(pwd)/.cartesi/image:/data \
    -v $(pwd):/output \
    ghcr.io/zippiehq/cartesi-carize:latest /carize.sh
```

## Step 3: Set Environment Variables

Set the environment variables using the output files generated by `carize.sh`:

```bash
CID=$(cat output.cid)
SIZE=$(cat output.size)
MACHINE_HASH=$(xxd -p .cartesi/image/hash | tr -d '\n')
```

## Step 4: Upload CAR Files to Coprocessor solver

- Request for a pre-signed URL

```bash
curl -X POST "<SOLVER_URL>/upload" -d ""
```

Running this command returns an object containing a pre-signed URL to which the car file is uploaded and an upload ID for identifying the upload.

- Upload Carfile to the pre-signed URL

```bash
curl -X PUT "<PRESIGNED_URL>" \
     -H "Content-Type: application/octet-stream" \
     --data-binary "@output.car"
```

Note, that this upload process takes a while to upload, depending on your network speed and also the size of the Carfile.

- Publish upload ID

```bash
curl -X POST "<SOLVER_URL>/publish/<UPLOAD_ID>" -d ""
```

This command returns an operator ID and the current state of your program download process. Note that it is to be called only once and any subsequent call will be blocked, resulting in an error message.

- Check publish status

```bash
curl -X GET "<SOLVER_URL>/publish_status/<UPLOAD_ID>" -d ""
```

This returns the status of the download process for your program and can be called as many tines as necessary. To proceed with other steps you need to receive a response containing the machine state: "dag_importing_complete", any other response either symbolizes, that there has been an error or that the download process is still ongoing.

## Step 5: Ensure Coprocessor Has Your Program

Finally, notify the Coprocessor to register your program:

```bash
curl -X POST "https://cartesi-coprocessor-solver-prod.fly.dev/ensure/$CID/$MACHINE_HASH/$SIZE"
```

and proceed after receiving the response `"operator_ids_with_states":{"<ID>":"ready"}}%`
